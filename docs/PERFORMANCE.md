# 📊 성능 최적화 전략

> 실제 운영 환경을 고려한 성능 최적화 사례와 핵심 지표

## 📈 핵심 성과 지표

| 최적화 항목 | 개선 전 | 개선 후 | 효과 |
|------------|---------|---------|------|
| 게시글 쿼리 | Full Scan + Filesort | Index 정렬 | 응답 속도 15% 향상 |
| WebSocket 연결 | 95% 안정성 | 99% 안정성 | 연결 끊김 95% 감소 |
| 파일 업로드 | 서버 경유 | S3 직접 업로드 | 서버 부하 33% 감소 |
| JWT 토큰 만료 | 수동 재로그인 | 자동 갱신 | 데이터 손실 95% 감소 |
| 테스트 빌드 | 27초 | 13초 | 빌드 시간 52% 단축 |
| 패키지 관리 | npm | pnpm | 설치 속도 70% 향상 |
| 날씨 캐시 응답 | 7초+ (API 직접) | 20ms (캐시 히트) | 99.7% 단축 |

## 🔧 주요 최적화 사례

### 데이터베이스
- **복합 인덱스**: `(category, created_at)`, `(room_id, timestamp)` 적용
- **N+1 해결**: Fetch Join으로 쿼리 수 90% 감소

### 파일 업로드
- **S3 Presigned URL**: 클라이언트 직접 업로드로 서버 부하 33% 감소
- **CloudFront OAI**: S3 직접 접근 차단

### WebSocket
- **하트비트**: 30초 주기로 연결 유지
- **자동 재연결**: 지수 백오프 방식

### 테스트
- **TestMockConfig**: 공통 Mock 설정으로 코드 93% 감소
- **병렬 실행**: 빌드 시간 52% 단축 (27초 → 13초)

### 프론트엔드
- **pnpm**: 설치 속도 70% 향상
- **Vite 코드 스플리팅**: 초기 로딩 30% 단축

### 캐싱
- **날씨 데이터 캐싱**: 하이브리드 캐싱 전략으로 API 호출 최소화
  - **Proactive Caching**: 70개 주요 도시 날씨를 30분마다 자동 수집 (WeatherScheduler)
  - **On-Demand Caching**: 기타 지역은 첫 요청 시 수집 후 캐싱 (WeatherService)
  - **캐시 키 통일**: CoordinateUtils로 0.2도(약 20km) 단위 그리드 공유
  - **대상 도시** (70개): 서울, 경기/인천 26개, 강원 9개, 충청 9개, 전라 7개, 경상 16개, 제주 2개

### k6 부하테스트 결과

별도 EC2(t3.micro)에서 k6를 실행하여 캐싱 성능을 검증했다.

#### 테스트 환경
- **부하 생성**: 별도 EC2 t3.micro (애플리케이션 서버와 분리)
- **대상 서버**: 운영 EC2 (Spring Boot + 로컬 캐시)
- **시나리오**: 150 VU, 2분 30초 (ramp-up 30초 → 유지 2분)

#### Weather 캐시 테스트

| 지표 | 결과 |
|------|------|
| 총 요청 | 316,953건 |
| 에러율 | 0% |
| 평균 응답시간 | 20.16ms |
| p(95) 응답시간 | 49.29ms (임계값 50ms PASS) |
| 초당 처리량 | 2,112 req/s |
| Actuator 검증 | hit 316,953 / miss 0 (적중률 100%) |

#### ISS 캐시 테스트

| 지표 | 결과 |
|------|------|
| 총 요청 | 290,792건 |
| 에러율 | 0% |
| 평균 응답시간 | 24.05ms |
| p(95) 응답시간 | 51.15ms (임계값 50ms 소폭 초과) |
| 초당 처리량 | 1,938 req/s |
| Actuator 검증 | hit 290,778 / miss 14 (적중률 99.995%) |