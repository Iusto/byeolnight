# 01. 설계 철학 및 DDD 개요

> 기능을 나열하지 않고, 도메인 문제를 명확히 식별하고 해결하는 백엔드 구조

## 🎯 목표

* "돌아가기만 하는 백엔드"가 아닌, **운영환경에서도 견고한 서비스** 설계
* 유지보수와 확장에 유리한 **도메인 중심 구조** 구축
* 복잡한 기능들을 단순히 기술로 푸는 것이 아니라, **업무 용어 중심의 도메인 모델링**으로 해결

## 🧠 도메인 주도 설계(DDD) 적용

> DDD는 단순한 폴더 구조 분리가 아닌, **비즈니스 도메인을 코드로 명확히 표현**하는 설계 방법론입니다.

### 본 프로젝트에서의 DDD 적용

**❌ 잘못된 DDD 이해**: 폴더를 domain/service/controller로 나누는 것
**✅ 올바른 DDD 적용**: 비즈니스 언어와 코드가 일치하는 도메인 모델 구축

#### 실제 적용 사례
- **유비쿼터스 언어**: `Post`, `Message`, `Token` 등 기획 언어와 코드 용어 일치
- **도메인 모델**: 각 엔티티가 실제 비즈니스 규칙을 포함 (예: User.lockAccount(), Post.blind())
- **Bounded Context**: 인증, 게시글, 쪽지 등 각 도메인의 독립성 보장
- **애그리거트**: Post-Comment, User-Token 등 일관성 경계 명확화

### 📌 실용적 DDD 접근

**본 프로젝트는 순수 DDD가 아닌 실용적 DDD를 채택했습니다.**

#### 주요 설계 결정

1. **JPA 엔티티 = 도메인 모델**
   - 도메인 모델과 영속성 모델을 통합
   - 소규모 프로젝트에서 분리는 과도한 복잡도
   - 트레이드오프: 영속성 기술 결합 ↔ 개발 생산성

2. **비즈니스 로직은 도메인 모델에**
   - 엔티티에 비즈니스 메서드 포함 (User.lockAccount(), Post.blind())
   - 도메인 규칙을 코드로 명확히 표현
   - 빈약한 도메인 모델(Anemic Domain Model) 지양

3. **인프라 의존성은 분리**
   - S3, Redis, 외부 API는 infrastructure 계층
   - 도메인 로직과 기술 구현 분리
   - 도메인별 패키지로 Bounded Context 보장

## 💡 본 프로젝트에서의 적용 방식

| 항목                  | 적용 방식                                        |
| ------------------- | -------------------------------------------- |
| **도메인 식별**          | 인증, 게시글, 채팅, 쪽지, 알림 등 각각 독립 도메인으로 정의         |
| **Bounded Context** | 도메인별 패키지 분리 + 내부 모델 독립 운영                    |
| **유비쿼터스 언어**        | "Post", "Message", "Token" 등 실제 기획 언어와 일치    |
| **애그리거트**           | 사용자, 게시글, 쪽지 등은 각각 Aggregate Root로 설계        |
| **서비스 계층 구분**       | Domain Service vs Application Service 명확히 분리 |
| **인프라 분리**          | Redis, S3, 외부 API는 infrastructure 계층에서 관리    |

## ✅ DDD 적용의 이점

* 변경에 강한 구조 (도메인 단위로 격리됨)
* 도메인 별 테스트 용이 (Mock 없이 단위 테스트 가능)
* 읽기 쉬운 코드 → 신규 참여자 온보딩 빠름
* 운영 환경에서의 예외 대응 및 로깅 체계 강화

---

👉 다음 문서: [02. 도메인 모델 개요](./02_domain-model.md)